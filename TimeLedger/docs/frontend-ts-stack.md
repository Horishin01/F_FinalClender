# フロントエンド TypeScript / フレームワーク選定メモ

## TL;DR（結論）
- **まずは「素のASP.NET MVC + TS化」**: esbuild（またはtsc）で最小セットを作り、既存JSを段階的にTSへ置換。
- **次点**: UIが複雑になるページに限り、**軽量なSvelteまたはPreact**をマウントするハイブリッド構成。
- **React/Vue本格採用**は「共通コンポーネントを大量に使い回す」「状態管理が重い」「将来SPA化」を見据えるタイミングで検討。

## 選定基準
- **保守性/型安全**: TSで型を担保できること。型推論・エディタ体験が良いか。
- **導入コスト**: 既存MVC/Razorとの共存が容易か。設定ファイル/依存関係の重さ。
- **再利用性**: コンポーネント化のしやすさ、デザインシステムへの拡張性。
- **学習コスト**: チームが短期でキャッチアップできるか。
- **パフォーマンス/バンドル**: 初期表示を重くしないか。SSRやコード分割の必要性。

## 主要な選択肢
1) **Plain TS + esbuild/tsc（現行MVCに最小導入）**
   - 利点: 既存構成に最小追加で型安全化。ビルドが速い。Razorとの相性がそのまま。
   - 注意: 状態管理/コンポーネント体系は自前。大規模UIには向かない。
2) **Svelte（またはPreact）を特定ページにマウント**
   - 利点: 軽量・習得しやすい・コンポーネント再利用が簡単。ハイブリッドで導入しやすい。
   - 注意: 開発者が触ったことがない場合はミニPoC推奨。SSRは後付けでも可。
3) **React/Vueを本格採用**
   - 利点: エコシステムが最も厚い（状態管理、UIキット、デバッグツール）。
   - 注意: バンドルが重くなりがち。Routing/状態管理も入れると初期コストが高い。
4) **Blazor WASM**（C#統一案）
   - 利点: フロントもC#で書ける一貫性。
   - 注意: バンドルサイズ/初期ロードが大きく、今回の「軽いUI実験」用途にはオーバーキル。

## 推奨ロードマップ（段階導入）
1. **Step 0: ツールチェーン整備**  
   - `npm init` → `typescript` + `esbuild` または `tsc --watch`。`src/ts` → `wwwroot/js` へ出力。
   - ESLint（typescript-eslint）を入れ、最低限のルールで型漏れを検知。
2. **Step 1: 既存JSをTS化**  
   - FlowリストやPacklistなどのローカル機能から着手。`strict: true`で型を付与。
3. **Step 2: コンポーネント化が必要なページだけSvelte/Preactを導入**  
   - Razorに`<div id="app-root">`を置き、該当ページだけマウント。Shared部分は現行のまま。
4. **Step 3: 本格的な共通UI/状態管理が必要ならReact/Vueを検討**  
   - その時点でRouter/状態管理（Zustand/Redux/Pinia等）を評価。デザインシステムが固まるならここ。

## 選定の目安（チェックリスト）
- UIがシンプル: 「Plain TS + Razor」で十分
- UIが増える/再利用が欲しい: Svelte/Preactで局所コンポーネント化
- 大規模・共通部品を大量配布: React/Vue
- C#で統一したい: Blazor（ただしサイズ許容できるか要検討）

## 導入時のメモ
- バンドル戦略: esbuildで`bundle+minify`、SourceMapオン。ページ単位でエントリを分けて初期ロードを軽量に。
- 型共有: APIレスポンスなどは、将来APIスキーマ（OpenAPI）から型生成する余地あり。短期は手書き型でOK。
- CSS: 既存の`wwwroot/css`を活かしつつ、コンポーネント化する場合はCSS ModulesやScoped CSS（Svelte）を検討。
- テスト: UI単位ならVitest/Jest、フレームワーク導入時はStorybookでUI検証を検討。
